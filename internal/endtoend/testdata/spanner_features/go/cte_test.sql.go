// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: cte_test.sql

package spanner_features

import (
	"context"
	"database/sql"
)

const testArrayAgg = `-- name: TestArrayAgg :one
SELECT ARRAY_AGG(name) as all_names
FROM users
WHERE deleted_at IS NULL;
`

func (q *Queries) TestArrayAgg(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, testArrayAgg)
	var all_names interface{}
	err := row.Scan(&all_names)
	return all_names, err
}

const testCTEWithJoin = `-- name: TestCTEWithJoin :many
WITH 
  active_users AS (
    SELECT id, name FROM users WHERE deleted_at IS NULL
  ),
  recent_posts AS (
    SELECT user_id, title FROM posts WHERE status = 'published'
  )
SELECT 
  u.name,
  p.title
FROM active_users u
JOIN recent_posts p ON u.id = p.user_id;
`

type TestCTEWithJoinRow struct {
	Name  sql.NullString
	Title sql.NullString
}

func (q *Queries) TestCTEWithJoin(ctx context.Context) ([]TestCTEWithJoinRow, error) {
	rows, err := q.db.QueryContext(ctx, testCTEWithJoin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestCTEWithJoinRow
	for rows.Next() {
		var i TestCTEWithJoinRow
		if err := rows.Scan(&i.Name, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const testExtractDate = `-- name: TestExtractDate :one
SELECT 
  EXTRACT(YEAR FROM deleted_at) as year,
  EXTRACT(MONTH FROM deleted_at) as month,
  EXTRACT(DAY FROM deleted_at) as day
FROM users
WHERE id = @user_id;
`

type TestExtractDateRow struct {
	Year  int64
	Month int64
	Day   int64
}

func (q *Queries) TestExtractDate(ctx context.Context, id string) (TestExtractDateRow, error) {
	row := q.db.QueryRowContext(ctx, testExtractDate, id)
	var i TestExtractDateRow
	err := row.Scan(&i.Year, &i.Month, &i.Day)
	return i, err
}

const testSafeDivide = `-- name: TestSafeDivide :one
SELECT SAFE.DIVIDE(score, 10) as safe_score
FROM users
WHERE id = @user_id;
`

func (q *Queries) TestSafeDivide(ctx context.Context, id string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, testSafeDivide, id)
	var safe_score interface{}
	err := row.Scan(&safe_score)
	return safe_score, err
}

const testSimpleCTE = `-- name: TestSimpleCTE :many

WITH active_users AS (
  SELECT id, name 
  FROM users 
  WHERE deleted_at IS NULL
)
SELECT id, name FROM active_users;
`

type TestSimpleCTERow struct {
	ID   string
	Name sql.NullString
}

// Test CTE (WITH clause) support
func (q *Queries) TestSimpleCTE(ctx context.Context) ([]TestSimpleCTERow, error) {
	rows, err := q.db.QueryContext(ctx, testSimpleCTE)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestSimpleCTERow
	for rows.Next() {
		var i TestSimpleCTERow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const testStringAgg = `-- name: TestStringAgg :one
SELECT STRING_AGG(name, ', ') as names_list
FROM users
WHERE deleted_at IS NULL;
`

func (q *Queries) TestStringAgg(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, testStringAgg)
	var names_list string
	err := row.Scan(&names_list)
	return names_list, err
}
