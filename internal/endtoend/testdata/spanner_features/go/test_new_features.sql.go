// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: test_new_features.sql

package spanner_features

import (
	"context"
	"database/sql"
)

const testBetween = `-- name: TestBetween :many
SELECT id, name, score
FROM users
WHERE score BETWEEN 50 AND 80;
`

type TestBetweenRow struct {
	ID    string
	Name  sql.NullString
	Score sql.NullInt64
}

func (q *Queries) TestBetween(ctx context.Context) ([]TestBetweenRow, error) {
	rows, err := q.db.QueryContext(ctx, testBetween)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestBetweenRow
	for rows.Next() {
		var i TestBetweenRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Score); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const testComplexExpression = `-- name: TestComplexExpression :one
SELECT 
  COUNT(*) as total,
  IF(COUNT(*) > 0, 'Has Users', 'No Users') as status
FROM users
WHERE NOT deleted_at IS NULL;
`

type TestComplexExpressionRow struct {
	Total  interface{}
	Status interface{}
}

func (q *Queries) TestComplexExpression(ctx context.Context) (TestComplexExpressionRow, error) {
	row := q.db.QueryRowContext(ctx, testComplexExpression)
	var i TestComplexExpressionRow
	err := row.Scan(&i.Total, &i.Status)
	return i, err
}

const testCountStar = `-- name: TestCountStar :one
SELECT COUNT(*) as total_users
FROM users;
`

func (q *Queries) TestCountStar(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, testCountStar)
	var total_users interface{}
	err := row.Scan(&total_users)
	return total_users, err
}

const testCountStarGroupBy = `-- name: TestCountStarGroupBy :many
SELECT status, COUNT(*) as count
FROM users
GROUP BY status;
`

type TestCountStarGroupByRow struct {
	Status sql.NullString
	Count  interface{}
}

func (q *Queries) TestCountStarGroupBy(ctx context.Context) ([]TestCountStarGroupByRow, error) {
	rows, err := q.db.QueryContext(ctx, testCountStarGroupBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestCountStarGroupByRow
	for rows.Next() {
		var i TestCountStarGroupByRow
		if err := rows.Scan(&i.Status, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const testExtract = `-- name: TestExtract :one
SELECT 
  EXTRACT(YEAR FROM created_at) as year,
  EXTRACT(MONTH FROM created_at) as month,
  EXTRACT(DAY FROM created_at) as day
FROM users
WHERE id = @user_id;
`

type TestExtractRow struct {
	Year  interface{}
	Month interface{}
	Day   interface{}
}

func (q *Queries) TestExtract(ctx context.Context, id string) (TestExtractRow, error) {
	row := q.db.QueryRowContext(ctx, testExtract, id)
	var i TestExtractRow
	err := row.Scan(&i.Year, &i.Month, &i.Day)
	return i, err
}

const testIfFunction = `-- name: TestIfFunction :one
SELECT 
  IF(score >= 60, 'Pass', 'Fail') as result
FROM users
WHERE id = @user_id;
`

func (q *Queries) TestIfFunction(ctx context.Context, id string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, testIfFunction, id)
	var result interface{}
	err := row.Scan(&result)
	return result, err
}

const testNotBetween = `-- name: TestNotBetween :many
SELECT id, name, score
FROM users
WHERE score NOT BETWEEN 50 AND 80;
`

type TestNotBetweenRow struct {
	ID    string
	Name  sql.NullString
	Score sql.NullInt64
}

func (q *Queries) TestNotBetween(ctx context.Context) ([]TestNotBetweenRow, error) {
	rows, err := q.db.QueryContext(ctx, testNotBetween)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestNotBetweenRow
	for rows.Next() {
		var i TestNotBetweenRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Score); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const testUnaryMinus = `-- name: TestUnaryMinus :one
SELECT -score as negative_score
FROM users
WHERE id = @user_id;
`

func (q *Queries) TestUnaryMinus(ctx context.Context, id string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, testUnaryMinus, id)
	var negative_score interface{}
	err := row.Scan(&negative_score)
	return negative_score, err
}

const testUnaryNot = `-- name: TestUnaryNot :many

SELECT id, name
FROM users
WHERE NOT (score > 80);
`

type TestUnaryNotRow struct {
	ID   string
	Name sql.NullString
}

// Test new expression implementations
func (q *Queries) TestUnaryNot(ctx context.Context) ([]TestUnaryNotRow, error) {
	rows, err := q.db.QueryContext(ctx, testUnaryNot)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestUnaryNotRow
	for rows.Next() {
		var i TestUnaryNotRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
