// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package spanner_features

import (
	"context"
	"database/sql"
)

const getActiveUsers = `-- name: GetActiveUsers :many
SELECT id, name 
FROM users 
WHERE deleted_at IS NULL;
`

type GetActiveUsersRow struct {
	ID   string
	Name sql.NullString
}

// Test IS NULL/IS NOT NULL
func (q *Queries) GetActiveUsers(ctx context.Context) ([]GetActiveUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveUsersRow
	for rows.Next() {
		var i GetActiveUsersRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeletedUsers = `-- name: GetDeletedUsers :many
SELECT id, name
FROM users
WHERE deleted_at IS NOT NULL;
`

type GetDeletedUsersRow struct {
	ID   string
	Name sql.NullString
}

func (q *Queries) GetDeletedUsers(ctx context.Context) ([]GetDeletedUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, getDeletedUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeletedUsersRow
	for rows.Next() {
		var i GetDeletedUsersRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserDisplayName = `-- name: GetUserDisplayName :one
SELECT COALESCE(name, 'Anonymous') as display_name
FROM users WHERE id = @user_id;
`

// Test COALESCE function
func (q *Queries) GetUserDisplayName(ctx context.Context, id string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getUserDisplayName, id)
	var display_name interface{}
	err := row.Scan(&display_name)
	return display_name, err
}

const getUserGrade = `-- name: GetUserGrade :one
SELECT 
  name,
  CASE 
    WHEN score >= 90 THEN 'Excellent'
    WHEN score >= 70 THEN 'Good'
    WHEN score >= 50 THEN 'Pass'
    ELSE 'Fail'
  END as grade
FROM users WHERE id = @user_id;
`

type GetUserGradeRow struct {
	Name  sql.NullString
	Grade string
}

// Test CASE WHEN expressions
func (q *Queries) GetUserGrade(ctx context.Context, id string) (GetUserGradeRow, error) {
	row := q.db.QueryRowContext(ctx, getUserGrade, id)
	var i GetUserGradeRow
	err := row.Scan(&i.Name, &i.Grade)
	return i, err
}

const getUserIdAsInt = `-- name: GetUserIdAsInt :one
SELECT CAST(id AS INT64) as numeric_id
FROM users WHERE id = @user_id;
`

// Test CAST operations
func (q *Queries) GetUserIdAsInt(ctx context.Context, id string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUserIdAsInt, id)
	var numeric_id int64
	err := row.Scan(&numeric_id)
	return numeric_id, err
}

const getUserWithPosts = `-- name: GetUserWithPosts :many
SELECT 
    u.id as user_id,
    u.name as user_name,
    p.id as post_id,
    p.title as post_title
FROM users u
INNER JOIN posts p ON u.id = p.user_id
WHERE u.deleted_at IS NULL;
`

type GetUserWithPostsRow struct {
	UserID    string
	UserName  sql.NullString
	PostID    string
	PostTitle sql.NullString
}

// Test JOIN operations
func (q *Queries) GetUserWithPosts(ctx context.Context) ([]GetUserWithPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserWithPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserWithPostsRow
	for rows.Next() {
		var i GetUserWithPostsRow
		if err := rows.Scan(
			&i.UserID,
			&i.UserName,
			&i.PostID,
			&i.PostTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByStatus = `-- name: GetUsersByStatus :many
SELECT id, name
FROM users
WHERE status IN ('active', 'pending', 'verified');
`

type GetUsersByStatusRow struct {
	ID   string
	Name sql.NullString
}

// Test IN operator
func (q *Queries) GetUsersByStatus(ctx context.Context) ([]GetUsersByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersByStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByStatusRow
	for rows.Next() {
		var i GetUsersByStatusRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithPostCount = `-- name: GetUsersWithPostCount :many
SELECT 
    u.id,
    u.name,
    COUNT(p.id) as post_count
FROM users u
LEFT JOIN posts p ON u.id = p.user_id
GROUP BY u.id, u.name;
`

type GetUsersWithPostCountRow struct {
	ID        string
	Name      sql.NullString
	PostCount int64
}

// Test LEFT JOIN
func (q *Queries) GetUsersWithPostCount(ctx context.Context) ([]GetUsersWithPostCountRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersWithPostCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersWithPostCountRow
	for rows.Next() {
		var i GetUsersWithPostCountRow
		if err := rows.Scan(&i.ID, &i.Name, &i.PostCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
