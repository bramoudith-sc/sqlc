// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package spanner_features

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const getActiveUsers = `-- name: GetActiveUsers :many
SELECT id, name 
FROM users 
WHERE deleted_at IS NULL;
`

type GetActiveUsersRow struct {
	ID   string
	Name sql.NullString
}

// Test IS NULL/IS NOT NULL
func (q *Queries) GetActiveUsers(ctx context.Context) ([]GetActiveUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveUsersRow
	for rows.Next() {
		var i GetActiveUsersRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeletedUsers = `-- name: GetDeletedUsers :many
SELECT id, name
FROM users
WHERE deleted_at IS NOT NULL;
`

type GetDeletedUsersRow struct {
	ID   string
	Name sql.NullString
}

func (q *Queries) GetDeletedUsers(ctx context.Context) ([]GetDeletedUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, getDeletedUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDeletedUsersRow
	for rows.Next() {
		var i GetDeletedUsersRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFirstNonNullValue = `-- name: GetFirstNonNullValue :one
SELECT COALESCE(name, status, 'No Value') as first_value
FROM users WHERE id = @user_id;
`

// Test complex COALESCE with multiple arguments
func (q *Queries) GetFirstNonNullValue(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRowContext(ctx, getFirstNonNullValue, id)
	var first_value string
	err := row.Scan(&first_value)
	return first_value, err
}

const getUserDisplayName = `-- name: GetUserDisplayName :one
SELECT COALESCE(name, 'Anonymous') as display_name
FROM users WHERE id = @user_id;
`

// Test COALESCE function
func (q *Queries) GetUserDisplayName(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserDisplayName, id)
	var display_name string
	err := row.Scan(&display_name)
	return display_name, err
}

const getUserGrade = `-- name: GetUserGrade :one
SELECT 
  name,
  CASE 
    WHEN score >= 90 THEN 'Excellent'
    WHEN score >= 70 THEN 'Good'
    WHEN score >= 50 THEN 'Pass'
    ELSE 'Fail'
  END as grade
FROM users WHERE id = @user_id;
`

type GetUserGradeRow struct {
	Name  sql.NullString
	Grade string
}

// Test CASE WHEN expressions
func (q *Queries) GetUserGrade(ctx context.Context, id string) (GetUserGradeRow, error) {
	row := q.db.QueryRowContext(ctx, getUserGrade, id)
	var i GetUserGradeRow
	err := row.Scan(&i.Name, &i.Grade)
	return i, err
}

const getUserIdAsInt = `-- name: GetUserIdAsInt :one
SELECT CAST(id AS INT64) as numeric_id
FROM users WHERE id = @user_id;
`

// Test CAST operations
func (q *Queries) GetUserIdAsInt(ctx context.Context, id string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUserIdAsInt, id)
	var numeric_id int64
	err := row.Scan(&numeric_id)
	return numeric_id, err
}

const getUserNameOrDefault = `-- name: GetUserNameOrDefault :one
SELECT IFNULL(name, 'Unknown User') as user_name
FROM users WHERE id = @user_id;
`

// Test IFNULL function
func (q *Queries) GetUserNameOrDefault(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserNameOrDefault, id)
	var user_name string
	err := row.Scan(&user_name)
	return user_name, err
}

const getUserScoreOrDefault = `-- name: GetUserScoreOrDefault :one
SELECT COALESCE(score, 0) as user_score
FROM users WHERE id = @user_id;
`

// Test COALESCE with numbers
func (q *Queries) GetUserScoreOrDefault(ctx context.Context, id string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUserScoreOrDefault, id)
	var user_score int64
	err := row.Scan(&user_score)
	return user_score, err
}

const getUserScoreOrZero = `-- name: GetUserScoreOrZero :one
SELECT IFNULL(score, 100) as score_value
FROM users WHERE id = @user_id;
`

// Test IFNULL with numbers
func (q *Queries) GetUserScoreOrZero(ctx context.Context, id string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getUserScoreOrZero, id)
	var score_value int64
	err := row.Scan(&score_value)
	return score_value, err
}

const getUserStatusNullIfDeleted = `-- name: GetUserStatusNullIfDeleted :one
SELECT NULLIF(status, 'deleted') as active_status
FROM users WHERE id = @user_id;
`

// Test NULLIF function
func (q *Queries) GetUserStatusNullIfDeleted(ctx context.Context, id string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getUserStatusNullIfDeleted, id)
	var active_status interface{}
	err := row.Scan(&active_status)
	return active_status, err
}

const getUserWithPosts = `-- name: GetUserWithPosts :many
SELECT 
    u.id as user_id,
    u.name as user_name,
    p.id as post_id,
    p.title as post_title
FROM users u
INNER JOIN posts p ON u.id = p.user_id
WHERE u.deleted_at IS NULL;
`

type GetUserWithPostsRow struct {
	UserID    string
	UserName  sql.NullString
	PostID    string
	PostTitle sql.NullString
}

// Test JOIN operations
func (q *Queries) GetUserWithPosts(ctx context.Context) ([]GetUserWithPostsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserWithPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserWithPostsRow
	for rows.Next() {
		var i GetUserWithPostsRow
		if err := rows.Scan(
			&i.UserID,
			&i.UserName,
			&i.PostID,
			&i.PostTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByStatus = `-- name: GetUsersByStatus :many
SELECT id, name
FROM users
WHERE status IN ('active', 'pending', 'verified');
`

type GetUsersByStatusRow struct {
	ID   string
	Name sql.NullString
}

// Test IN operator
func (q *Queries) GetUsersByStatus(ctx context.Context) ([]GetUsersByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersByStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByStatusRow
	for rows.Next() {
		var i GetUsersByStatusRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersWithPostCount = `-- name: GetUsersWithPostCount :many
SELECT 
    u.id,
    u.name,
    COUNT(p.id) as post_count
FROM users u
LEFT JOIN posts p ON u.id = p.user_id
GROUP BY u.id, u.name;
`

type GetUsersWithPostCountRow struct {
	ID        string
	Name      sql.NullString
	PostCount int64
}

// Test LEFT JOIN
func (q *Queries) GetUsersWithPostCount(ctx context.Context) ([]GetUsersWithPostCountRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsersWithPostCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersWithPostCountRow
	for rows.Next() {
		var i GetUsersWithPostCountRow
		if err := rows.Scan(&i.ID, &i.Name, &i.PostCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const testArrayIndexAccess = `-- name: TestArrayIndexAccess :one
SELECT 
  ['apple', 'banana', 'cherry'][1] as second_fruit,
  ARRAY<INT64>[10, 20, 30][OFFSET(0)] as first_number;
`

type TestArrayIndexAccessRow struct {
	SecondFruit string
	FirstNumber int64
}

// Test array index access
func (q *Queries) TestArrayIndexAccess(ctx context.Context) (TestArrayIndexAccessRow, error) {
	row := q.db.QueryRowContext(ctx, testArrayIndexAccess)
	var i TestArrayIndexAccessRow
	err := row.Scan(&i.SecondFruit, &i.FirstNumber)
	return i, err
}

const testArrayLiteral = `-- name: TestArrayLiteral :one
SELECT CASE WHEN true THEN [1, 2, 3] ELSE [4, 5, 6] END as array_value;
`

func (q *Queries) TestArrayLiteral(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, testArrayLiteral)
	var array_value interface{}
	err := row.Scan(&array_value)
	return array_value, err
}

const testArraySubQuery = `-- name: TestArraySubQuery :many
SELECT 
  u.id,
  u.name,
  ARRAY(SELECT p.title FROM posts p WHERE p.user_id = u.id) as post_titles
FROM users u;
`

type TestArraySubQueryRow struct {
	ID         string
	Name       sql.NullString
	PostTitles interface{}
}

func (q *Queries) TestArraySubQuery(ctx context.Context) ([]TestArraySubQueryRow, error) {
	rows, err := q.db.QueryContext(ctx, testArraySubQuery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TestArraySubQueryRow
	for rows.Next() {
		var i TestArraySubQueryRow
		if err := rows.Scan(&i.ID, &i.Name, &i.PostTitles); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const testBooleanLiteral = `-- name: TestBooleanLiteral :one
SELECT CASE WHEN true THEN true ELSE false END as bool_value;
`

func (q *Queries) TestBooleanLiteral(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, testBooleanLiteral)
	var bool_value string
	err := row.Scan(&bool_value)
	return bool_value, err
}

const testBytesLiteral = `-- name: TestBytesLiteral :one
SELECT CASE WHEN true THEN b'hello' ELSE b'world' END as bytes_value;
`

func (q *Queries) TestBytesLiteral(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, testBytesLiteral)
	var bytes_value string
	err := row.Scan(&bytes_value)
	return bytes_value, err
}

const testCaseWithNumberElse = `-- name: TestCaseWithNumberElse :one
SELECT CASE WHEN score > 50 THEN score ELSE 0 END as result
FROM users WHERE id = @user_id;
`

// Test simple CASE with number in ELSE
func (q *Queries) TestCaseWithNumberElse(ctx context.Context, id string) (int64, error) {
	row := q.db.QueryRowContext(ctx, testCaseWithNumberElse, id)
	var result int64
	err := row.Scan(&result)
	return result, err
}

const testDateColumn = `-- name: TestDateColumn :one
SELECT deleted_at as date_col FROM users WHERE id = @user_id;
`

// Debug: Test just returning a date column
func (q *Queries) TestDateColumn(ctx context.Context, id string) (sql.NullTime, error) {
	row := q.db.QueryRowContext(ctx, testDateColumn, id)
	var date_col sql.NullTime
	err := row.Scan(&date_col)
	return date_col, err
}

const testDateLiteral = `-- name: TestDateLiteral :one
SELECT CASE WHEN true THEN DATE '2024-01-01' ELSE DATE '2024-12-31' END as date_value;
`

func (q *Queries) TestDateLiteral(ctx context.Context) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, testDateLiteral)
	var date_value time.Time
	err := row.Scan(&date_value)
	return date_value, err
}

const testExistsSubQuery = `-- name: TestExistsSubQuery :one
SELECT 
  u.id,
  u.name,
  EXISTS(SELECT 1 FROM posts p WHERE p.user_id = u.id) as has_posts
FROM users u
WHERE u.id = @user_id;
`

type TestExistsSubQueryRow struct {
	ID       string
	Name     sql.NullString
	HasPosts bool
}

func (q *Queries) TestExistsSubQuery(ctx context.Context, id string) (TestExistsSubQueryRow, error) {
	row := q.db.QueryRowContext(ctx, testExistsSubQuery, id)
	var i TestExistsSubQueryRow
	err := row.Scan(&i.ID, &i.Name, &i.HasPosts)
	return i, err
}

const testExplicitCast = `-- name: TestExplicitCast :one
SELECT CAST('2024-01-01' AS DATE) as cast_date;
`

// Test explicit CAST
func (q *Queries) TestExplicitCast(ctx context.Context) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, testExplicitCast)
	var cast_date time.Time
	err := row.Scan(&cast_date)
	return cast_date, err
}

const testFloatLiteral = `-- name: TestFloatLiteral :one
SELECT CASE WHEN true THEN 3.14 ELSE 0.0 END as float_value;
`

func (q *Queries) TestFloatLiteral(ctx context.Context) (float64, error) {
	row := q.db.QueryRowContext(ctx, testFloatLiteral)
	var float_value float64
	err := row.Scan(&float_value)
	return float_value, err
}

const testIntegerLiteral = `-- name: TestIntegerLiteral :one
SELECT CASE WHEN true THEN 42 ELSE 0 END as int_value;
`

// Test all Spanner literal types with CASE expressions
func (q *Queries) TestIntegerLiteral(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, testIntegerLiteral)
	var int_value int64
	err := row.Scan(&int_value)
	return int_value, err
}

const testIntervalRange = `-- name: TestIntervalRange :one
SELECT INTERVAL '1-2' YEAR TO MONTH as interval_range;
`

func (q *Queries) TestIntervalRange(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, testIntervalRange)
	var interval_range interface{}
	err := row.Scan(&interval_range)
	return interval_range, err
}

const testIntervalSingle = `-- name: TestIntervalSingle :one
SELECT INTERVAL 5 DAY as interval_days;
`

// Test INTERVAL support
func (q *Queries) TestIntervalSingle(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, testIntervalSingle)
	var interval_days interface{}
	err := row.Scan(&interval_days)
	return interval_days, err
}

const testJsonLiteral = `-- name: TestJsonLiteral :one
SELECT CASE WHEN true THEN JSON '{"key": "value"}' ELSE JSON '{}' END as json_value;
`

func (q *Queries) TestJsonLiteral(ctx context.Context) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, testJsonLiteral)
	var json_value json.RawMessage
	err := row.Scan(&json_value)
	return json_value, err
}

const testMixedStruct = `-- name: TestMixedStruct :one
SELECT 
  STRUCT(u.id as uid, 'fixed' as fixed_val, u.score as uscore).uscore as mixed_score
FROM users u
WHERE u.id = @user_id;
`

func (q *Queries) TestMixedStruct(ctx context.Context, id string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, testMixedStruct, id)
	var mixed_score interface{}
	err := row.Scan(&mixed_score)
	return mixed_score, err
}

const testNullLiteral = `-- name: TestNullLiteral :one
SELECT CASE WHEN false THEN 'value' ELSE NULL END as null_value;
`

func (q *Queries) TestNullLiteral(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, testNullLiteral)
	var null_value interface{}
	err := row.Scan(&null_value)
	return null_value, err
}

const testNumericLiteral = `-- name: TestNumericLiteral :one
SELECT CASE WHEN true THEN NUMERIC '123.456' ELSE NUMERIC '0.0' END as numeric_value;
`

func (q *Queries) TestNumericLiteral(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, testNumericLiteral)
	var numeric_value string
	err := row.Scan(&numeric_value)
	return numeric_value, err
}

const testScalarSubQuery = `-- name: TestScalarSubQuery :one
SELECT 
  u.name,
  (SELECT MAX(score) FROM users WHERE status = 'active') as max_score
FROM users u
WHERE u.id = @user_id;
`

type TestScalarSubQueryRow struct {
	Name     sql.NullString
	MaxScore interface{}
}

// Test subquery support
func (q *Queries) TestScalarSubQuery(ctx context.Context, id string) (TestScalarSubQueryRow, error) {
	row := q.db.QueryRowContext(ctx, testScalarSubQuery, id)
	var i TestScalarSubQueryRow
	err := row.Scan(&i.Name, &i.MaxScore)
	return i, err
}

const testSimpleDateCast = `-- name: TestSimpleDateCast :one
SELECT DATE '2024-01-01' as date_value;
`

// Test TypeCast directly
func (q *Queries) TestSimpleDateCast(ctx context.Context) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, testSimpleDateCast)
	var date_value time.Time
	err := row.Scan(&date_value)
	return date_value, err
}

const testSimpleNumericCast = `-- name: TestSimpleNumericCast :one
SELECT NUMERIC '123.456' as numeric_value;
`

func (q *Queries) TestSimpleNumericCast(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, testSimpleNumericCast)
	var numeric_value string
	err := row.Scan(&numeric_value)
	return numeric_value, err
}

const testSimpleTimestampCast = `-- name: TestSimpleTimestampCast :one
SELECT TIMESTAMP '2024-01-01 10:00:00' as timestamp_value;
`

func (q *Queries) TestSimpleTimestampCast(ctx context.Context) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, testSimpleTimestampCast)
	var timestamp_value time.Time
	err := row.Scan(&timestamp_value)
	return timestamp_value, err
}

const testStringLiteral = `-- name: TestStringLiteral :one
SELECT CASE WHEN true THEN 'hello' ELSE 'world' END as string_value;
`

func (q *Queries) TestStringLiteral(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, testStringLiteral)
	var string_value string
	err := row.Scan(&string_value)
	return string_value, err
}

const testStructFieldAccess = `-- name: TestStructFieldAccess :one
SELECT 
  STRUCT(1 as id, 'John' as name).name as person_name;
`

// Test struct field access
func (q *Queries) TestStructFieldAccess(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, testStructFieldAccess)
	var person_name string
	err := row.Scan(&person_name)
	return person_name, err
}

const testStructFieldAccess2 = `-- name: TestStructFieldAccess2 :one
SELECT 
  STRUCT<id INT64, name STRING>(42, 'Alice').name as typed_name;
`

func (q *Queries) TestStructFieldAccess2(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, testStructFieldAccess2)
	var typed_name string
	err := row.Scan(&typed_name)
	return typed_name, err
}

const testStructFieldAccessAny = `-- name: TestStructFieldAccessAny :one
SELECT 
  STRUCT(1 as id, 'John' as name).unknown_field as unknown;
`

func (q *Queries) TestStructFieldAccessAny(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, testStructFieldAccessAny)
	var unknown interface{}
	err := row.Scan(&unknown)
	return unknown, err
}

const testStructFieldAccessBool = `-- name: TestStructFieldAccessBool :one
SELECT 
  STRUCT<id INT64, name STRING, active BOOL>(42, 'Alice', true).active as is_active;
`

func (q *Queries) TestStructFieldAccessBool(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, testStructFieldAccessBool)
	var is_active interface{}
	err := row.Scan(&is_active)
	return is_active, err
}

const testStructFieldAccessDate = `-- name: TestStructFieldAccessDate :one
SELECT 
  STRUCT<created DATE, name STRING>(DATE '2024-01-01', 'Test').created as created_date;
`

func (q *Queries) TestStructFieldAccessDate(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, testStructFieldAccessDate)
	var created_date interface{}
	err := row.Scan(&created_date)
	return created_date, err
}

const testStructFieldAccessFloat = `-- name: TestStructFieldAccessFloat :one
SELECT 
  STRUCT<score FLOAT64, name STRING>(3.14, 'Pi').score as score_value;
`

func (q *Queries) TestStructFieldAccessFloat(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, testStructFieldAccessFloat)
	var score_value interface{}
	err := row.Scan(&score_value)
	return score_value, err
}

const testStructFieldAccessInt = `-- name: TestStructFieldAccessInt :one
SELECT 
  STRUCT(1 as id, 'John' as name).id as person_id;
`

func (q *Queries) TestStructFieldAccessInt(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, testStructFieldAccessInt)
	var person_id int64
	err := row.Scan(&person_id)
	return person_id, err
}

const testStructFieldAccessTypedInt = `-- name: TestStructFieldAccessTypedInt :one
SELECT 
  STRUCT<id INT64, name STRING, active BOOL>(42, 'Alice', true).id as typed_id;
`

func (q *Queries) TestStructFieldAccessTypedInt(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, testStructFieldAccessTypedInt)
	var typed_id int64
	err := row.Scan(&typed_id)
	return typed_id, err
}

const testStructWithTableColumns = `-- name: TestStructWithTableColumns :one
SELECT 
  STRUCT(u.id as user_id, u.name as user_name).user_name as name_from_struct
FROM users u
WHERE u.id = @user_id;
`

// Test STRUCT with table column references
func (q *Queries) TestStructWithTableColumns(ctx context.Context, id string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, testStructWithTableColumns, id)
	var name_from_struct interface{}
	err := row.Scan(&name_from_struct)
	return name_from_struct, err
}

const testStructWithTableColumnsInt = `-- name: TestStructWithTableColumnsInt :one
SELECT 
  STRUCT(u.id as uid, u.score as uscore).uscore as score_from_struct
FROM users u
WHERE u.id = @user_id;
`

func (q *Queries) TestStructWithTableColumnsInt(ctx context.Context, id string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, testStructWithTableColumnsInt, id)
	var score_from_struct interface{}
	err := row.Scan(&score_from_struct)
	return score_from_struct, err
}

const testTimestampLiteral = `-- name: TestTimestampLiteral :one
SELECT CASE WHEN true THEN TIMESTAMP '2024-01-01 10:00:00' ELSE TIMESTAMP '2024-12-31 23:59:59' END as timestamp_value;
`

func (q *Queries) TestTimestampLiteral(ctx context.Context) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, testTimestampLiteral)
	var timestamp_value time.Time
	err := row.Scan(&timestamp_value)
	return timestamp_value, err
}

const testTupleStruct = `-- name: TestTupleStruct :one
SELECT (100, 'tuple', DATE '2024-01-01') as tuple_value;
`

func (q *Queries) TestTupleStruct(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, testTupleStruct)
	var tuple_value interface{}
	err := row.Scan(&tuple_value)
	return tuple_value, err
}

const testTypedStruct = `-- name: TestTypedStruct :one
SELECT STRUCT<x INT64, y STRING, z BOOL>(42, 'world', false) as typed_struct;
`

func (q *Queries) TestTypedStruct(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, testTypedStruct)
	var typed_struct interface{}
	err := row.Scan(&typed_struct)
	return typed_struct, err
}

const testTypedStructWithTableColumns = `-- name: TestTypedStructWithTableColumns :one
SELECT 
  STRUCT<uid STRING, uname STRING>(u.id, u.name).uname as typed_name
FROM users u
WHERE u.id = @user_id;
`

func (q *Queries) TestTypedStructWithTableColumns(ctx context.Context, id string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, testTypedStructWithTableColumns, id)
	var typed_name interface{}
	err := row.Scan(&typed_name)
	return typed_name, err
}

const testTypelessStruct = `-- name: TestTypelessStruct :one
SELECT STRUCT(1, 'hello', true) as struct_value;
`

// Test STRUCT support
func (q *Queries) TestTypelessStruct(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, testTypelessStruct)
	var struct_value interface{}
	err := row.Scan(&struct_value)
	return struct_value, err
}
